import path from 'path';
import { readFileIfExists, checkFileExists, getLanguageFromPath } from '../utils/file-utils.js';

export async function analyzeGraphQL(functionDir, analysis) {
  const schemaPath = path.join(functionDir, 'schema.graphql');
  
  // Check for schema.graphql
  const schemaContent = await readFileIfExists(schemaPath);
  if (!schemaContent) {
    analysis.inconsistencies.push({
      file: schemaPath,
      issue: 'Missing required schema.graphql file'
    });
  } else {
    // Check for auto-generated comments
    const autoGeneratedComment = schemaContent.includes('# This file is auto-generated') || 
                               schemaContent.includes('# please edit the ruby definition files') ||
                               schemaContent.includes('# Check out the "Docs" tab');

    if (autoGeneratedComment) {
      analysis.inconsistencies.push({
        file: schemaPath,
        issue: 'Contains auto-generated comments that should be removed',
        fix: 'Remove the auto-generated comment block from the top of the file'
      });
    }
  }

  const language = getLanguageFromPath(functionDir);

  // Check GraphQL query files and their content
  const checkQueryFile = async (basePath, exportName) => {
    // Try both .graphql and .graphql.liquid versions
    const liquidPath = `${basePath}.liquid`;
    const nonLiquidPath = basePath;
    
    const liquidContent = await readFileIfExists(liquidPath);
    const nonLiquidContent = await readFileIfExists(nonLiquidPath);
    
    // If neither file exists, return early
    if (!liquidContent && !nonLiquidContent) {
      return;
    }

    // Use whichever content exists (prefer non-liquid if both exist)
    const content = nonLiquidContent || liquidContent;
    const filePath = nonLiquidContent ? nonLiquidPath : liquidPath;

    // Determine expected query name based on language and export name
    let expectedQueryName;
    if (language === 'javascript') {
      expectedQueryName = `${exportName}Input`;
    } else {
      // Both rust and wasm use 'Input'
      expectedQueryName = 'Input';
    }

    // Check if the query has the expected name, allowing for whitespace
    const queryMatch = content.match(/query\s+([^\s{(]+)/);
    if (!queryMatch || queryMatch[1] !== expectedQueryName) {
      analysis.inconsistencies.push({
        file: filePath,
        issue: `Incorrect query name for ${language} function`,
        expected: `query ${expectedQueryName}`,
        fix: `Rename the query to "query ${expectedQueryName}"`
      });
    }
  };

  // Check run.graphql
  await checkQueryFile(path.join(functionDir, 'src', 'run.graphql'), 'Run');

  // Check fetch.graphql if it exists
  await checkQueryFile(path.join(functionDir, 'src', 'fetch.graphql'), 'Fetch');

  // Check for any additional .graphql files referenced in shopify.extension.toml
  const extensionTomlPath = path.join(functionDir, 'shopify.extension.toml.liquid');
  const extensionContent = await readFileIfExists(extensionTomlPath);
  if (extensionContent) {
    const inputQueryMatches = extensionContent.match(/input_query\s*=\s*"([^"]+)"/g) || [];
    
    for (const match of inputQueryMatches) {
      const queryPath = match.split('"')[1];
      // Get the base path without any .liquid extension
      const basePath = path.join(functionDir, queryPath.replace(/\.liquid$/, ''));
      
      // Check for either version of the file
      const hasLiquidFile = await checkFileExists(`${basePath}.liquid`);
      const hasNonLiquidFile = await checkFileExists(basePath);
      
      // If either version exists, it's valid
      if (!hasLiquidFile && !hasNonLiquidFile) {
        // If neither exists, suggest creating either version
        const suggestedPath = queryPath.endsWith('.liquid') ? queryPath : `${queryPath}.liquid`;
        analysis.inconsistencies.push({
          file: path.join(functionDir, queryPath),
          issue: `Missing GraphQL query file referenced in shopify.extension.toml.liquid`,
          fix: `Create either ${queryPath.replace(/\.liquid$/, '')} or ${suggestedPath}`
        });
      }
    }
  }
} 